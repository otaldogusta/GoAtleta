const fs = require("fs");
const https = require("https");
const path = require("path");

const ENV_PATH = path.resolve(__dirname, "..", ".env");
const OUTPUT_PATH = path.resolve(__dirname, "..", "src", "ui", "figma-colors.ts");

const THEME_KEYS = [
  "background",
  "card",
  "border",
  "text",
  "muted",
  "placeholder",
  "inputBg",
  "inputText",
  "primaryBg",
  "primaryText",
  "primaryDisabledBg",
  "secondaryBg",
  "secondaryText",
  "dangerBg",
  "dangerBorder",
  "dangerText",
  "thumbFallback",
  "successBg",
  "successText",
  "warningBg",
  "warningText",
  "dangerSolidBg",
  "dangerSolidText",
  "infoBg",
  "infoText",
];

const normalizeKey = (value) => value.toLowerCase().replace(/[^a-z0-9]/g, "");
const themeKeyMap = THEME_KEYS.reduce((acc, key) => {
  acc[normalizeKey(key)] = key;
  return acc;
}, {});

const parseEnv = (content) => {
  const env = {};
  content.split("\n").forEach((line) => {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) return;
    const index = trimmed.indexOf("=");
    if (index === -1) return;
    const key = trimmed.slice(0, index).trim();
    const value = trimmed.slice(index + 1).trim();
    env[key] = value;
  });
  return env;
};

const requestJson = (url, token) =>
  new Promise((resolve, reject) => {
    const req = https.get(
      url,
      {
        headers: {
          "X-Figma-Token": token,
        },
      },
      (res) => {
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => {
          if (res.statusCode && res.statusCode >= 400) {
            return reject(new Error(`Figma API error ${res.statusCode}: ${data}`));
          }
          try {
            resolve(JSON.parse(data));
          } catch (error) {
            reject(error);
          }
        });
      }
    );
    req.on("error", reject);
  });

const toColorValue = (paint) => {
  if (!paint || paint.type !== "SOLID" || !paint.color) return null;
  const r = Math.round(paint.color.r * 255);
  const g = Math.round(paint.color.g * 255);
  const b = Math.round(paint.color.b * 255);
  const a = paint.opacity  paint.color.a  1;
  if (a < 1) {
    return `rgba(${r}, ${g}, ${b}, ${Number(a.toFixed(3))})`;
  }
  const toHex = (value) => value.toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
};

const pickSolidPaint = (fills) => {
  if (!Array.isArray(fills)) return null;
  return fills.find((paint) => paint.type === "SOLID") || null;
};

const chunk = (list, size) => {
  const result = [];
  for (let i = 0; i < list.length; i += size) {
    result.push(list.slice(i, i + size));
  }
  return result;
};

const run = async () => {
  if (!fs.existsSync(ENV_PATH)) {
    throw new Error("Arquivo .env não encontrado.");
  }
  const env = parseEnv(fs.readFileSync(ENV_PATH, "utf8"));
  const token = env.FIGMA_TOKEN;
  const fileId = env.FIGMA_FILE_ID;
  if (!token || !fileId) {
    throw new Error("FIGMA_TOKEN ou FIGMA_FILE_ID não encontrado no .env.");
  }

  const stylesUrl = `https://api.figma.com/v1/files/${fileId}/styles`;
  const stylesResponse = await requestJson(stylesUrl, token);
  const styles = stylesResponse.meta && stylesResponse.meta.styles
     stylesResponse.meta.styles
    : [];
  const colorStyles = styles.filter((style) => style.style_type === "FILL");
  const nodeIds = colorStyles.map((style) => style.node_id);
  const styleByNode = new Map(colorStyles.map((style) => [style.node_id, style]));

  const colorsRaw = {};
  for (const group of chunk(nodeIds, 50)) {
    const nodesUrl =
      `https://api.figma.com/v1/files/${fileId}/nodes?ids=` +
      encodeURIComponent(group.join(","));
    const nodesResponse = await requestJson(nodesUrl, token);
    const nodes = nodesResponse.nodes || {};
    Object.entries(nodes).forEach(([nodeId, node]) => {
      const style = styleByNode.get(nodeId);
      if (!style || !node || !node.document) return;
      const paint = pickSolidPaint(node.document.fills);
      const colorValue = toColorValue(paint);
      if (colorValue) {
        colorsRaw[style.name] = colorValue;
      }
    });
  }

  const result = { light: {}, dark: {}, raw: {} };
  Object.entries(colorsRaw).forEach(([name, value]) => {
    result.raw[name] = value;
    const parts = name.split("/");
    if (parts.length < 2) return;
    const mode = parts[0].trim().toLowerCase();
    if (mode !== "light" && mode !== "dark") return;
    const tokenName = normalizeKey(parts.slice(1).join("/"));
    const resolvedKey = themeKeyMap[tokenName];
    if (!resolvedKey) return;
    result[mode][resolvedKey] = value;
  });

  const content = `/* eslint-disable */\n` +
    `// This file is auto-generated by scripts/sync-figma-colors.js\n` +
    `export const figmaColors = ${JSON.stringify(result, null, 2)} as const;\n`;
  fs.writeFileSync(OUTPUT_PATH, content, "utf8");
  console.log(`Atualizado: ${OUTPUT_PATH}`);
};

run().catch((error) => {
  console.error(error.message || error);
  process.exit(1);
});
